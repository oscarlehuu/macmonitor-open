name: Publish Release Assets

on:
  release:
    types:
      - published
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to publish (example: v0.4.1)"
        required: true
        type: string

permissions:
  contents: write

concurrency:
  group: publish-release-assets
  cancel-in-progress: false

env:
  SPARKLE_VERSION: 2.8.1
  UPDATES_REPO: ${{ vars.UPDATES_REPO || format('{0}/macmonitor-updates', github.repository_owner) }}

jobs:
  publish:
    runs-on: macos-15

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve release metadata
        id: meta
        env:
          EVENT_NAME: ${{ github.event_name }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          DISPATCH_TAG: ${{ github.event.inputs.tag }}
        shell: bash
        run: |
          set -euo pipefail

          tag="${RELEASE_TAG:-}"
          if [[ "${EVENT_NAME}" == "workflow_dispatch" ]]; then
            tag="${DISPATCH_TAG:-}"
          fi

          if [[ -z "${tag}" ]]; then
            echo "Release tag is required." >&2
            exit 1
          fi

          if [[ "${tag}" != v* ]]; then
            echo "Release tag must start with 'v' (received: ${tag})." >&2
            exit 1
          fi

          short_version="${tag#v}"
          build_version="${GITHUB_RUN_NUMBER}"

          echo "tag=${tag}" >> "${GITHUB_OUTPUT}"
          echo "short_version=${short_version}" >> "${GITHUB_OUTPUT}"
          echo "build_version=${build_version}" >> "${GITHUB_OUTPUT}"

      - name: Validate release secrets
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
          UPDATES_REPO_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}
          APPLE_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_CERTIFICATE_P12_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_NOTARY_KEY_ID: ${{ secrets.APPLE_NOTARY_KEY_ID }}
          APPLE_NOTARY_ISSUER_ID: ${{ secrets.APPLE_NOTARY_ISSUER_ID }}
          APPLE_NOTARY_API_KEY_BASE64: ${{ secrets.APPLE_NOTARY_API_KEY_BASE64 }}
        run: |
          set -euo pipefail
          [[ -n "${SPARKLE_PRIVATE_KEY:-}" ]] || (echo "Missing required secret: SPARKLE_PRIVATE_KEY" && exit 1)
          [[ -n "${UPDATES_REPO_TOKEN:-}" ]] || (echo "Missing required secret: UPDATES_REPO_TOKEN" && exit 1)
          [[ -n "${APPLE_CERTIFICATE_P12_BASE64:-}" ]] || (echo "Missing required secret: APPLE_CERTIFICATE_P12_BASE64" && exit 1)
          [[ -n "${APPLE_CERTIFICATE_PASSWORD:-}" ]] || (echo "Missing required secret: APPLE_CERTIFICATE_PASSWORD" && exit 1)
          [[ -n "${APPLE_SIGNING_IDENTITY:-}" ]] || (echo "Missing required secret: APPLE_SIGNING_IDENTITY" && exit 1)
          [[ -n "${APPLE_NOTARY_KEY_ID:-}" ]] || (echo "Missing required secret: APPLE_NOTARY_KEY_ID" && exit 1)
          [[ -n "${APPLE_NOTARY_ISSUER_ID:-}" ]] || (echo "Missing required secret: APPLE_NOTARY_ISSUER_ID" && exit 1)
          [[ -n "${APPLE_NOTARY_API_KEY_BASE64:-}" ]] || (echo "Missing required secret: APPLE_NOTARY_API_KEY_BASE64" && exit 1)

      - name: Install XcodeGen
        run: brew install xcodegen

      - name: Download Sparkle CLI tools
        id: sparkle
        shell: bash
        run: |
          set -euo pipefail
          tools_dir="${RUNNER_TEMP}/sparkle-tools"
          mkdir -p "${tools_dir}"
          curl -fsSL -o "${RUNNER_TEMP}/Sparkle.tar.xz" \
            "https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz"
          tar -xJf "${RUNNER_TEMP}/Sparkle.tar.xz" \
            --strip-components=2 \
            -C "${tools_dir}" \
            ./bin/generate_appcast \
            ./bin/sign_update
          chmod +x "${tools_dir}/generate_appcast" "${tools_dir}/sign_update"
          echo "tools_dir=${tools_dir}" >> "${GITHUB_OUTPUT}"

      - name: Build release artifact
        id: build
        env:
          APPLE_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_CERTIFICATE_P12_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_NOTARY_KEY_ID: ${{ secrets.APPLE_NOTARY_KEY_ID }}
          APPLE_NOTARY_ISSUER_ID: ${{ secrets.APPLE_NOTARY_ISSUER_ID }}
          APPLE_NOTARY_API_KEY_BASE64: ${{ secrets.APPLE_NOTARY_API_KEY_BASE64 }}
        shell: bash
        run: |
          set -euo pipefail
          xcodegen generate

          derived_data="${RUNNER_TEMP}/derived-data"
          short_version="${{ steps.meta.outputs.short_version }}"
          build_version="${{ steps.meta.outputs.build_version }}"
          tag="${{ steps.meta.outputs.tag }}"

          keychain_path="${RUNNER_TEMP}/build.keychain-db"
          keychain_password="$(openssl rand -hex 16)"
          cert_path="${RUNNER_TEMP}/build-cert.p12"

          if echo "${APPLE_CERTIFICATE_P12_BASE64}" | base64 --decode > "${cert_path}" 2>/dev/null; then
            :
          else
            echo "${APPLE_CERTIFICATE_P12_BASE64}" | base64 -D > "${cert_path}"
          fi

          security create-keychain -p "${keychain_password}" "${keychain_path}"
          security set-keychain-settings -lut 21600 "${keychain_path}"
          security unlock-keychain -p "${keychain_password}" "${keychain_path}"
          security import "${cert_path}" -k "${keychain_path}" -P "${APPLE_CERTIFICATE_PASSWORD}" -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "${keychain_password}" "${keychain_path}"
          security list-keychains -d user -s "${keychain_path}" login.keychain-db
          security default-keychain -s "${keychain_path}"

          signing_args=(
            CODE_SIGN_STYLE=Manual
            CODE_SIGN_IDENTITY="${APPLE_SIGNING_IDENTITY}"
          )

          archive_path="${RUNNER_TEMP}/MacMonitor.xcarchive"

          xcodebuild \
            -project MacMonitor.xcodeproj \
            -scheme MacMonitor \
            -configuration Release \
            -destination 'platform=macOS' \
            -derivedDataPath "${derived_data}" \
            -archivePath "${archive_path}" \
            archive \
            MARKETING_VERSION="${short_version}" \
            CURRENT_PROJECT_VERSION="${build_version}" \
            ENABLE_HARDENED_RUNTIME=YES \
            "${signing_args[@]}"

          app_path="${archive_path}/Products/Applications/MacMonitor.app"
          if [[ ! -d "${app_path}" ]]; then
            echo "Built app not found at ${app_path}" >&2
            exit 1
          fi

          # Brute-force clear any inherited entitlements/signature metadata before re-signing.
          codesign --remove-signature "${app_path}" || true
          codesign --force --deep --options runtime --timestamp \
            --sign "${APPLE_SIGNING_IDENTITY}" \
            --entitlements MacMonitor/Config/Release.entitlements \
            "${app_path}"

          codesign --verify --deep --strict --verbose=2 "${app_path}"
          signature_details="$(codesign -dv --verbose=4 "${app_path}" 2>&1)"
          echo "${signature_details}"

          if echo "${signature_details}" | grep -q "Signature=adhoc"; then
            echo "Release app is ad-hoc signed; refusing to publish an invalid Sparkle update." >&2
            exit 1
          fi

          team_identifier="$(echo "${signature_details}" | sed -n 's/^TeamIdentifier=//p' | head -n1)"
          if [[ -z "${team_identifier}" || "${team_identifier}" == "not set" ]]; then
            echo "Release app does not have a TeamIdentifier; refusing to publish." >&2
            exit 1
          fi

          plist_path="${app_path}/Contents/Info.plist"
          built_short_version="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "${plist_path}")"
          built_build_version="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "${plist_path}")"

          if [[ "${built_short_version}" != "${short_version}" ]]; then
            echo "Expected short version ${short_version}, got ${built_short_version}" >&2
            exit 1
          fi

          notary_key_path="${RUNNER_TEMP}/AuthKey_${APPLE_NOTARY_KEY_ID}.p8"
          if echo "${APPLE_NOTARY_API_KEY_BASE64}" | base64 --decode > "${notary_key_path}" 2>/dev/null; then
            :
          else
            echo "${APPLE_NOTARY_API_KEY_BASE64}" | base64 -D > "${notary_key_path}"
          fi
          chmod 600 "${notary_key_path}"

          notary_submission_path="${RUNNER_TEMP}/MacMonitor-${built_short_version}-${built_build_version}-notary.zip"
          ditto -c -k --sequesterRsrc --keepParent "${app_path}" "${notary_submission_path}"

          notary_result_path="${RUNNER_TEMP}/notary-result.json"
          xcrun notarytool submit "${notary_submission_path}" \
            --key "${notary_key_path}" \
            --key-id "${APPLE_NOTARY_KEY_ID}" \
            --issuer "${APPLE_NOTARY_ISSUER_ID}" \
            --wait \
            --output-format json > "${notary_result_path}"

          /usr/bin/python3 -m json.tool "${notary_result_path}" || cat "${notary_result_path}"
          notary_status="$(/usr/bin/python3 -c 'import json,sys; print(json.load(open(sys.argv[1], encoding="utf-8")).get("status", ""))' "${notary_result_path}")"
          notary_id="$(/usr/bin/python3 -c 'import json,sys; print(json.load(open(sys.argv[1], encoding="utf-8")).get("id", ""))' "${notary_result_path}")"
          if [[ "${notary_status}" != "Accepted" ]]; then
            echo "Notarization did not return Accepted status (status=${notary_status:-unknown})." >&2
            if [[ -n "${notary_id}" ]]; then
              echo "Fetching notary rejection log for submission ${notary_id}..." >&2
              xcrun notarytool log "${notary_id}" \
                --key "${notary_key_path}" \
                --key-id "${APPLE_NOTARY_KEY_ID}" \
                --issuer "${APPLE_NOTARY_ISSUER_ID}" || true
            fi
            exit 1
          fi

          xcrun stapler staple -v "${app_path}"
          xcrun stapler validate -v "${app_path}"
          spctl --assess --type execute --verbose=2 "${app_path}"

          asset_name="MacMonitor-${built_short_version}-${built_build_version}.zip"
          asset_path="${RUNNER_TEMP}/${asset_name}"

          ditto -c -k --sequesterRsrc --keepParent "${app_path}" "${asset_path}"

          notes_path="${RUNNER_TEMP}/release-notes.md"
          updates_owner="${UPDATES_REPO%%/*}"
          updates_repo_name="${UPDATES_REPO#*/}"
          sparkle_appcast_url="https://${updates_owner}.github.io/${updates_repo_name}/appcast.xml"
          {
            echo "Automated release asset publish for \\`${GITHUB_REPOSITORY}@${GITHUB_SHA}\\`."
            echo
            echo "- Tag: ${tag}"
            echo "- Version: ${built_short_version} (${built_build_version})"
            echo "- Signing identity: ${APPLE_SIGNING_IDENTITY}"
            echo "- Notarized: yes"
            echo "- Sparkle appcast: ${sparkle_appcast_url}"
          } > "${notes_path}"

          echo "asset_name=${asset_name}" >> "${GITHUB_OUTPUT}"
          echo "asset_path=${asset_path}" >> "${GITHUB_OUTPUT}"
          echo "notes_path=${notes_path}" >> "${GITHUB_OUTPUT}"

      - name: Upload asset to source release
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail

          tag="${{ steps.meta.outputs.tag }}"
          asset_path="${{ steps.build.outputs.asset_path }}"
          asset_name="${{ steps.build.outputs.asset_name }}"
          notes_path="${{ steps.build.outputs.notes_path }}"

          if gh release view "${tag}" >/dev/null 2>&1; then
            gh release upload "${tag}" "${asset_path}#${asset_name}" --clobber
          else
            gh release create "${tag}" "${asset_path}#${asset_name}" \
              --title "MacMonitor ${tag}" \
              --notes-file "${notes_path}" \
              --latest
          fi

      - name: Publish update payload + appcast
        env:
          GH_TOKEN: ${{ secrets.UPDATES_REPO_TOKEN }}
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
          SOURCE_RELEASE_NOTES: ${{ github.event.release.body }}
          SOURCE_RELEASE_URL: ${{ github.event.release.html_url }}
        shell: bash
        run: |
          set -euo pipefail

          tag="${{ steps.meta.outputs.tag }}"
          asset_path="${{ steps.build.outputs.asset_path }}"
          asset_name="${{ steps.build.outputs.asset_name }}"
          sparkle_tools_dir="${{ steps.sparkle.outputs.tools_dir }}"

          updates_dir="${RUNNER_TEMP}/updates-repo"
          archives_dir="${RUNNER_TEMP}/sparkle-archives"
          updates_owner="${UPDATES_REPO%%/*}"
          updates_repo_name="${UPDATES_REPO#*/}"
          release_notes_url_prefix="https://${updates_owner}.github.io/${updates_repo_name}/"
          download_prefix="https://github.com/${UPDATES_REPO}/releases/download/${tag}/"

          git clone "https://x-access-token:${GH_TOKEN}@github.com/${UPDATES_REPO}.git" "${updates_dir}"
          mkdir -p "${archives_dir}"

          cp "${asset_path}" "${archives_dir}/${asset_name}"
          if [[ -f "${updates_dir}/appcast.xml" ]]; then
            cp "${updates_dir}/appcast.xml" "${archives_dir}/appcast.xml"
          fi

          notes_stub="${archives_dir}/${asset_name%.zip}.txt"
          notes_target="${updates_dir}/$(basename "${notes_stub}")"
          release_notes="${SOURCE_RELEASE_NOTES:-}"
          release_url="${SOURCE_RELEASE_URL:-https://github.com/${GITHUB_REPOSITORY}/releases/tag/${tag}}"

          if [[ -z "${release_notes}" ]]; then
            release_notes="No release notes were provided for ${tag}."
          fi

          {
            echo "MacMonitor ${tag}"
            echo
            printf '%s\n' "${release_notes}"
            echo
            echo "Full release notes: ${release_url}"
          } > "${notes_stub}"
          cp "${notes_stub}" "${notes_target}"

          if gh release view "${tag}" --repo "${UPDATES_REPO}" >/dev/null 2>&1; then
            gh release upload "${tag}" "${asset_path}#${asset_name}" --repo "${UPDATES_REPO}" --clobber
          else
            gh release create "${tag}" "${asset_path}#${asset_name}" \
              --repo "${UPDATES_REPO}" \
              --title "MacMonitor ${tag}" \
              --notes "Automated Sparkle payload from ${GITHUB_REPOSITORY}@${GITHUB_SHA}."
          fi

          echo "${SPARKLE_PRIVATE_KEY}" | "${sparkle_tools_dir}/generate_appcast" \
            --ed-key-file - \
            --download-url-prefix "${download_prefix}" \
            --release-notes-url-prefix "${release_notes_url_prefix}" \
            --full-release-notes-url "${release_url}" \
            --link "https://github.com/${GITHUB_REPOSITORY}" \
            "${archives_dir}"

          cp "${archives_dir}/appcast.xml" "${updates_dir}/appcast.xml"

          git -C "${updates_dir}" config user.name "github-actions[bot]"
          git -C "${updates_dir}" config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          notes_basename="$(basename "${notes_stub}")"
          if git -C "${updates_dir}" status --porcelain -- appcast.xml "${notes_basename}" | grep -q .; then
            git -C "${updates_dir}" add appcast.xml "${notes_basename}"
            git -C "${updates_dir}" commit -m "chore: update appcast for ${tag}"
            git -C "${updates_dir}" push origin main
          fi
